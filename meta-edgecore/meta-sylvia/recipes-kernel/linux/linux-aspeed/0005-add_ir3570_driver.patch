diff --git a/drivers/hwmon/pmbus/ec-ir3570.c b/drivers/hwmon/pmbus/ec-ir3570.c
new file mode 100644
index 000000000000..d91096091842
--- /dev/null
+++ b/drivers/hwmon/pmbus/ec-ir3570.c
@@ -0,0 +1,362 @@
+/*
+ * Copyright 2019 EDGE-CORE Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/bitops.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/i2c.h>
+#include <linux/jiffies.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/pmbus.h>
+
+#include "pmbus.h"
+
+#define EC_IR3570_ID_CMD				0x99
+#define EC_IR3570_FRU_CMD				0x9A
+#define EC_IR3570_PN_CMD				0x9B
+#define EC_IR3570_LOC_CMD				0x9C
+#define EC_IR3570_DATE_CMD				0x9D
+#define EC_IR3570_SN_CMD				0x9E
+#define EC_IR3570_DEVID_CMD				0xAD
+#define EC_IR3570_FORMATE_CMD				0xC3
+#define EC_IR3570_FWID_CMD				0xD1
+#define EC_IR3570_FW_REV_CMD				0xD2
+
+/* STATUS_MFR_SPECIFIC bits */
+#define EC_IR3570_MFR_FAN_FAULT			BIT(0)
+#define EC_IR3570_MFR_THERMAL_FAULT		BIT(1)
+#define EC_IR3570_MFR_OV_FAULT			BIT(2)
+#define EC_IR3570_MFR_UV_FAULT			BIT(3)
+#define EC_IR3570_MFR_PS_KILL			BIT(4)
+#define EC_IR3570_MFR_OC_FAULT			BIT(5)
+#define EC_IR3570_MFR_VAUX_FAULT		BIT(6)
+#define EC_IR3570_MFR_CURRENT_SHARE_WARNING	BIT(7)
+
+enum {
+	IR3570_DEBUGFS_ID = 0,
+	IR3570_DEBUGFS_FRU,
+	IR3570_DEBUGFS_PN,
+	IR3570_DEBUGFS_LOC,
+	IR3570_DEBUGFS_DATE,
+	IR3570_DEBUGFS_SN,
+	IR3570_DEBUGFS_DEVID,
+	IR3570_DEBUGFS_FORMATE,
+	IR3570_DEBUGFS_FWID,
+	IR3570_DEBUGFS_FW_REV,
+	IR3570_DEBUGFS_NUM_ENTRIES
+};
+
+struct ec_ir3570_s {
+	struct i2c_client *client;
+
+	int debugfs_entries[IR3570_DEBUGFS_NUM_ENTRIES];
+};
+
+#define to_psu(x, y) container_of((x), struct ec_ir3570_s, debugfs_entries[(y)])
+
+static ssize_t ec_ir3570_debugfs_op(struct file *file, char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	u8 cmd;
+	int i, rc;
+	int *idxp = file->private_data;
+	int idx = *idxp;
+	struct ec_ir3570_s *psu = to_psu(idxp, idx);
+	char data[I2C_SMBUS_BLOCK_MAX] = { 0 };
+
+	switch (idx) {
+	case IR3570_DEBUGFS_ID:
+		cmd = EC_IR3570_ID_CMD;
+		break;
+	case IR3570_DEBUGFS_FRU:
+		cmd = EC_IR3570_FRU_CMD;
+		break;
+	case IR3570_DEBUGFS_PN:
+		cmd = EC_IR3570_PN_CMD;
+		break;
+	case IR3570_DEBUGFS_LOC:
+		cmd = EC_IR3570_LOC_CMD;
+		break;
+	case IR3570_DEBUGFS_DATE:
+		cmd = EC_IR3570_DATE_CMD;
+		break;
+	case IR3570_DEBUGFS_SN:
+		cmd = EC_IR3570_SN_CMD;
+		break;
+	case IR3570_DEBUGFS_DEVID:
+		cmd = EC_IR3570_DEVID_CMD;
+		break;
+	case IR3570_DEBUGFS_FORMATE:
+		cmd = EC_IR3570_FORMATE_CMD;
+		break;
+	case IR3570_DEBUGFS_FWID:
+		cmd = EC_IR3570_FWID_CMD;
+		break;
+	case IR3570_DEBUGFS_FW_REV:
+		cmd = EC_IR3570_FW_REV_CMD;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	rc = i2c_smbus_read_block_data(psu->client, cmd, data);
+	if (rc < 0)
+		return rc;
+
+done:
+	data[rc] = '\n';
+	rc += 2;
+
+	return simple_read_from_buffer(buf, count, ppos, data, rc);
+}
+
+static const struct file_operations ec_ir3570_fops = {
+	.llseek = noop_llseek,
+	.read = ec_ir3570_debugfs_op,
+	.open = simple_open,
+};
+
+static int ec_ir3570_read_byte_data(struct i2c_client *client, int page,
+				    int reg)
+{
+	int rc, mfr;
+
+	switch (reg) {
+	case PMBUS_STATUS_VOUT:
+	case PMBUS_STATUS_IOUT:
+	case PMBUS_STATUS_TEMPERATURE:
+	case PMBUS_STATUS_FAN_12:
+		rc = pmbus_read_byte_data(client, page, reg);
+		if (rc < 0)
+			return rc;
+
+		mfr = pmbus_read_byte_data(client, page,
+					   PMBUS_STATUS_MFR_SPECIFIC);
+		if (mfr < 0)
+			/*
+			 * Return the status register instead of an error,
+			 * since we successfully read status.
+			 */
+			return rc;
+
+		/* Add MFR_SPECIFIC bits to the standard pmbus status regs. */
+		if (reg == PMBUS_STATUS_FAN_12) {
+			if (mfr & EC_IR3570_MFR_FAN_FAULT)
+				rc |= PB_FAN_FAN1_FAULT;
+		} else if (reg == PMBUS_STATUS_TEMPERATURE) {
+			if (mfr & EC_IR3570_MFR_THERMAL_FAULT)
+				rc |= PB_TEMP_OT_FAULT;
+		} else if (reg == PMBUS_STATUS_VOUT) {
+			if (mfr & (EC_IR3570_MFR_OV_FAULT | EC_IR3570_MFR_VAUX_FAULT))
+				rc |= PB_VOLTAGE_OV_FAULT;
+			if (mfr & EC_IR3570_MFR_UV_FAULT)
+				rc |= PB_VOLTAGE_UV_FAULT;
+		} else if (reg == PMBUS_STATUS_IOUT) {
+			if (mfr & EC_IR3570_MFR_OC_FAULT)
+				rc |= PB_IOUT_OC_FAULT;
+			if (mfr & EC_IR3570_MFR_CURRENT_SHARE_WARNING)
+				rc |= PB_CURRENT_SHARE_FAULT;
+		}
+		break;
+	default:
+		rc = -ENODATA;
+		break;
+	}
+
+	return rc;
+}
+
+static int ec_ir3570_read_word_data(struct i2c_client *client, int page,
+				    int reg)
+{
+	int rc, mfr;
+
+	switch (reg) {
+	case PMBUS_STATUS_WORD:
+		rc = pmbus_read_word_data(client, page, reg);
+		if (rc < 0)
+			return rc;
+
+		mfr = pmbus_read_byte_data(client, page,
+					   PMBUS_STATUS_MFR_SPECIFIC);
+		if (mfr < 0)
+			/*
+			 * Return the status register instead of an error,
+			 * since we successfully read status.
+			 */
+			return rc;
+
+		if (mfr & EC_IR3570_MFR_PS_KILL)
+			rc |= PB_STATUS_OFF;
+		break;
+	case PMBUS_READ_VOUT:
+		rc = pmbus_read_word_data(client, page, reg);
+
+{
+        s16 exponent = ((s16)rc) >> 11;
+        s32 mantissa = (((s16)rc & 0x7ff) << 5) >> 5;
+	rc = mantissa * 1000L;
+        if( exponent >= 0 ){
+		rc <<= exponent;
+	}
+	else{
+		rc >>= (-exponent)+1;
+	}
+}
+		break;
+	default:
+		rc = -ENODATA;
+		break;
+	}
+
+	return rc;
+}
+
+static struct pmbus_driver_info ec_ir3570_info = {
+	.pages = 1,
+	.func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IOUT | PMBUS_HAVE_IIN | PMBUS_HAVE_VOUT |
+		PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_VOUT |
+		PMBUS_HAVE_STATUS_IOUT | PMBUS_HAVE_STATUS_INPUT | PMBUS_HAVE_STATUS_TEMP,
+	.read_byte_data = ec_ir3570_read_byte_data,
+	.read_word_data = ec_ir3570_read_word_data,
+};
+
+static struct pmbus_platform_data ec_ir3570_pdata = {
+	.flags = PMBUS_SKIP_STATUS_CHECK,
+};
+
+static int ec_ir3570_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)
+{
+	int i, rc, ret;
+	struct dentry *debugfs;
+	struct dentry *ec_ir3570_dir;
+	struct ec_ir3570_s *psu;
+	char buf[48];
+
+        if (!i2c_check_functionality(client->adapter,
+		I2C_FUNC_SMBUS_READ_BYTE_DATA |
+		I2C_FUNC_SMBUS_READ_WORD_DATA |
+		I2C_FUNC_SMBUS_READ_BLOCK_DATA))
+		return -ENODEV;
+
+	memset(buf, 0, sizeof(buf));
+	ret = i2c_smbus_read_block_data(client, PMBUS_MFR_ID, buf);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to read PMBUS_MFR_ID\n");
+		return ret;
+	}
+	if (ret < 5 || strncmp(buf, "ACBEL", strlen("ACBEL"))) {
+		dev_err(&client->dev, "MFR_ID unrecognised(%d) %s\n", ret, buf);
+		return -ENODEV;
+	}
+	dev_info(&client->dev, "MFR_ID got(%d) %s\n", strlen(buf), buf);
+
+	memset(buf, 0, sizeof(buf));
+	ret = i2c_smbus_read_block_data(client, PMBUS_MFR_MODEL, buf);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to read PMBUS_MFR_MODEL\n");
+		return ret;
+	}
+	if (ret < 14 || strncmp(buf, "FSF019", strlen("FSF019"))) {
+		dev_err(&client->dev, "MFR_MODEL unrecognised(%d) %s\n", ret, buf);
+		return -ENODEV;
+	}
+	dev_info(&client->dev, "MFR_MODEL got(%d) %s\n", strlen(buf), buf);
+
+	client->dev.platform_data = &ec_ir3570_pdata;
+	rc = pmbus_do_probe(client, id, &ec_ir3570_info);
+	if (rc)
+		return rc;
+
+	/*
+	 * Don't fail the probe if there isn't enough memory for leds and
+	 * debugfs.
+	 */
+	psu = devm_kzalloc(&client->dev, sizeof(*psu), GFP_KERNEL);
+	if (!psu)
+		return 0;
+
+	psu->client = client;
+
+	/* Don't fail the probe if we can't create debugfs */
+	debugfs = pmbus_get_debugfs_dir(client);
+	if (!debugfs)
+		return 0;
+
+	ec_ir3570_dir = debugfs_create_dir(client->name, debugfs);
+	if (!ec_ir3570_dir)
+		return 0;
+
+	for (i = 0; i < IR3570_DEBUGFS_NUM_ENTRIES; ++i)
+		psu->debugfs_entries[i] = i;
+
+	debugfs_create_file("id", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_ID],
+			    &ec_ir3570_fops);
+	debugfs_create_file("fru", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_FRU],
+			    &ec_ir3570_fops);
+	debugfs_create_file("part_number", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_PN],
+			    &ec_ir3570_fops);
+	debugfs_create_file("location", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_LOC],
+			    &ec_ir3570_fops);
+	debugfs_create_file("date", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_DATE],
+			    &ec_ir3570_fops);
+	debugfs_create_file("serial_number", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_SN],
+			    &ec_ir3570_fops);
+	debugfs_create_file("device_id", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_DEVID],
+			    &ec_ir3570_fops);
+	debugfs_create_file("formate", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_FORMATE],
+			    &ec_ir3570_fops);
+	debugfs_create_file("fwid", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_FWID],
+			    &ec_ir3570_fops);
+	debugfs_create_file("fw_rev", 0444, ec_ir3570_dir,
+			    &psu->debugfs_entries[IR3570_DEBUGFS_FW_REV],
+			    &ec_ir3570_fops);
+	return 0;
+}
+
+static const struct i2c_device_id ec_ir3570_id[] = {
+	{ "edge-core_ir3570", 1 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ec_ir3570_id);
+
+static const struct of_device_id ec_ir3570_of_match[] = {
+	{ .compatible = "edge-core,ir3570" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ec_ir3570_of_match);
+
+static struct i2c_driver ec_ir3570_driver = {
+	.driver = {
+		.name = "edge-core-ir3570",
+		.of_match_table = ec_ir3570_of_match,
+	},
+	.probe = ec_ir3570_probe,
+	.remove = pmbus_do_remove,
+	.id_table = ec_ir3570_id,
+};
+
+module_i2c_driver(ec_ir3570_driver);
+
+MODULE_AUTHOR("Simon Fan");
+MODULE_DESCRIPTION("PMBus driver for EDGE-CORE Network Common Form Factor power supplies");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hwmon/pmbus/Kconfig b/drivers/hwmon/pmbus/Kconfig
index a82018aaf473..7a0ce01df2a8 100644
--- a/drivers/hwmon/pmbus/Kconfig
+++ b/drivers/hwmon/pmbus/Kconfig
@@ -54,6 +54,16 @@ config SENSORS_IR35221
 	  This driver can also be built as a module. If so, the module will
 	  be called ir35521.
 
+config SENSORS_IR3570
+	tristate "Infineon IR3570/3580"
+	default n
+	help
+	  If you say yes here you get hardware monitoring support for the
+	  Infineon IR3570/3580 controller.
+
+	  This driver can also be built as a module. If so, the module will
+	  be called ir3570.
+
 config SENSORS_LM25066
 	tristate "National Semiconductor LM25066 and compatibles"
 	default n
diff --git a/drivers/hwmon/pmbus/Makefile b/drivers/hwmon/pmbus/Makefile
index ea0e39518c21..b0fd74d2897a 100644
--- a/drivers/hwmon/pmbus/Makefile
+++ b/drivers/hwmon/pmbus/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_SENSORS_PMBUS)	+= pmbus.o
 obj-$(CONFIG_SENSORS_IR35221)	+= ir35221.o
 obj-$(CONFIG_SENSORS_IR38064)	+= ir38064.o
+obj-$(CONFIG_SENSORS_IR3570)	+= ec-ir3570.o
 obj-$(CONFIG_SENSORS_ISL68137)	+= isl68137.o
 obj-$(CONFIG_SENSORS_LM25066)	+= lm25066.o
 obj-$(CONFIG_SENSORS_LTC2978)	+= ltc2978.o
 obj-$(CONFIG_SENSORS_LTC3815)	+= ltc3815.o
